<!DOCTYPE html public '-//W3C//DTD HTML 4.01//EN'
  'http://www.w3.org/TR/REC-html4/strict.dtd'>
<!-- Can I have bangs, plusses, or slashes in #tags? Spaces?
        Yes: plus, bang, star   No: space  Yes: slash, question, ampersand
        You can't put sharp in a path, so anything goes, really.
        Nonetheless, some of these confuse Netscape, so I'll avoid them.
 -->

<!--========================================================================-->
<html>
  <head>
    <meta name="keywords" content="Scheme, programming language, list processing, SRFI" />
    <link rev=made href="mailto:cowan@ccil.org" />
    <title>SRFI 130: Cursor-based string library</title>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <link rel="stylesheet" href="/srfi.css" type="text/css" />

    <!-- Should have a media=all to get, for example, printing to work.
      == But my Netscape will completely ignore the tag if I do that.
      -->
    <style type="text/css">
           /* A little general layout hackery for headers & the title. */
           body { margin-left: +7%;
                  font-family: "Helvetica", sans-serif;
                  }
           /* Netscape workaround: */
           td, th { font-family: "Helvetica", sans-serif; }

           code, pre { font-family: "courier new", "courier"; }

           div.inset { margin-left: +5%; }

           h1 { margin-left: -5%; }
           h1, h2 { clear: both; }
           h1, h2, h3, h4, h5, h6 { color: blue }
           div.title-text { font-size: large; font-weight: bold; }
	   h3 { margin-top: 2em; margin-bottom: 0em }

	   /* "Continue" class marks text that isn't really the start
	   ** of a new paragraph — e.g., continuing a para after a 
	   ** code sample.
	   */
	   p.continue { text-indent: 0em; margin-top: 0em}

           div.indent { margin-left: 2em; }       /* General indentation */
           pre.code-example { margin-left: 2em; } /* Indent code examples. */

           /* This stuff is for definition lists of defined procedures.
           ** A proc-def1 is used when you want a stack of procs to go
           ** with one dd body. In this case, make the first
           ** proc a proc-def1, following ones proc-defi's, and the last one
           ** a proc-defn.
           **
           ** Unfortunately, Netscape has huge bugs with respect to style
           ** sheets and dl list rendering. We have to set truly random
           ** values here to get the rendering to come out. The proper values
           ** are in the following style sheet, for Internet Explorer.
           ** In the following settings, the *comments* say what the 
           ** setting *really* causes Netscape to do.
           **
           ** Ugh. Professional coders sacrifice their self-respect,
           ** that others may live.
           */
           /* m-t ignored; m-b sets top margin space. */
           dt.proc-def1 { margin-top: 0ex; margin-bottom: 3ex; }
           dt.proc-defi { margin-top: 0ex; margin-bottom: 0ex; }
           dt.proc-defn { margin-top: 0ex; margin-bottom: 0ex; }

           /* m-t works weird depending on whether or not the last line
           ** of the previous entry was a pre. Set to zero.
           */
           dt.proc-def  { margin-top: 0ex; margin-bottom: 3ex; }

           /* m-b sets space between dd & dt; m-t ignored. */
           dd.proc-def { margin-bottom: 0.5ex; margin-top: 0ex; } 


           /* Boldface the name of a procedure when it's being defined. */
           code.proc-def { font-weight: bold; font-size: 110%}

           /* For the index of procedures. 
           ** Same hackery as for dt.proc-def, above.
           */
           /* m-b sets space between dd & dt; m-t ignored. */
           dd.proc-index  { margin-bottom: 0ex; margin-top: 0ex; } 
           /* What the fuck? */
           pre.proc-index { margin-top: -2ex; }

           /* Pull the table of contents back flush with the margin.
           ** Both NS & IE screw this up in different ways.
           */
           #toc-table { margin-top: -2ex; margin-left: -5%; }

           /* R5RS proc names are in italic; extended R5RS names 
           ** in italic boldface.
           */
           span.r5rs-proc { font-weight: bold; }
           span.r5rs-procx { font-style: italic; font-weight: bold; }

           /* Spread out bibliographic lists. */
           /* More Netscape-specific lossage; see the following stylesheet
           ** for the proper values (used by IE).
           */
           dt.biblio { margin-bottom: 3ex; }

           /* Links to draft copies (e.g., not at the official SRFI site)
           ** are colored in red, so people will use them during the 
           ** development process and kill them when the document's done.
           */
           a.draft { color: red; }
    </style>

    <style type="text/css" media=all>
           /* Nastiness: Here, I'm using a bug to work around a bug.
           ** Netscape rendering bugs mean you need bogus <dt> and <dd>
           ** margin settings — settings which screw up IE's proper rendering.
           ** Fortunately, Netscape has *another* bug: it will ignore this
           ** media=all style sheet. So I am placing the (proper) IE values
           ** here. Perhaps, one day, when these rendering bugs are fixed,
           ** this gross hackery can be removed.
           */
           dt.proc-def1 { margin-top: 3ex; margin-bottom: 0ex; }
           dt.proc-defi { margin-top: 0ex; margin-bottom: 0ex; }
           dt.proc-defn { margin-top: 0ex; margin-bottom: 0.5ex; }
           dt.proc-def  { margin-top: 3ex; margin-bottom: 0.5ex; }

           pre { margin-top: 1ex; }

           dd.proc-def { margin-bottom: 2ex; margin-top: 0.5ex; } 

           /* For the index of procedures. 
           ** Same hackery as for dt.proc-def, above.
           */
           dd.proc-index { margin-top: 0ex; } 
           pre.proc-index { margin-top: 0ex; }

           /* Spread out bibliographic lists. */
           dt.biblio { margin-top: 3ex; margin-bottom: 0ex; }
           dd.biblio { margin-bottom: 1ex; }
    </style>
  </head>

<body>

<!--========================================================================-->
<H1>Title</H1>

<div class=title-text>Cursor-based string library</div>

<!--========================================================================-->
<H1>Author</H1>

John Cowan

<H1>Status</H1>

<p>This SRFI is currently in <em>final</em> status. Here is <a href="https://srfi.schemers.org/srfi-process.html">an explanation</a> of each status that a SRFI can hold.  To provide input on this SRFI, please send email to <code><a href="mailto:srfi+minus+130+at+srfi+dotschemers+dot+org">srfi-130@<span class="antispam">nospam</span>srfi.schemers.org</a></code>.  To subscribe to the list, follow <a href="http://srfi.schemers.org/srfi-list-subscribe.html">these instructions</a>.  You can access previous messages via the mailing list <a href="https://srfi-email.schemers.org/srfi-130">archive</a>.</p>
<ul>
  <li>Received: 2015-12-02</li>
  <li>60-day deadline: 2016-02-01</li>
  <li>Draft #1 published: 2015-12-03</li>
  <li>Draft #2 published: 2015-12-13</li>
  <li>Draft #3 published: 2016-03-28</li>
  <li>Draft #4 published: 2016-04-12</li>
  <li>Draft #5 published: 2016-05-14</li>
  <li>Draft #6 published: 2016-05-14</li>
  <li>Draft #7 published: 2016-05-22</li>
  <li>Draft #8 published: 2016-05-23 (code changes only)</li>
  <li>Finalized: 2016-05-08</li>
  <li>Revised to fix errata:
    <ul>
      <li>2024-09-02 (Revised to fix missing argument in <a href="#string-fold">examples</a> of <code>string-fold</code> and <code>string-fold-right</code>.)</li></ul></li>
</ul>

<h1>Table of contents</H1>

<!-- A bug in netscape (?) keeps the first link in this UL from being active.
==== So the Abstract link be dead. 99/8/22 -Olin
-->
<ul id=toc-table>
<li><a href="#Abstract">Abstract</a>
<li><a href="#ProcedureIndex">Procedure index</a>
<li><a href="#Rationale">Rationale</a>
<li><a href="#Specification">Specification</a>
  <ul>
  <li><a href="#StringCursors">String cursors</a>
  <li><a href="#CallingPredicates">Calling predicates</a>
  <li><a href="#SharedStorage">Shared storage</a>
  <li><a href="#NamingConventions">Naming conventions</a>
  <li><a href="#Notation">Notation</a>
  <li><a href="#Procedures">Procedures</a>
    <ul>
    <li><a href="#CursorOperations">Cursor operations</a>
    <li><a href="#Predicates">Predicates</a>
    <li><a href="#Constructors">Constructors</a>
    <li><a href="#Conversion">Conversion</a>
    <li><a href="#Selection">Selection</a>
    <li><a href="#PrefixesSuffixes">Prefixes &amp; suffixes</a>
    <li><a href="#Searching">Searching</a>
    <li><a href="#TheWholeString">The whole string</a>
    </ul>

<li><a href="#SampleImp">Sample implementation</a>
<li><a href="#Acknowledgements">Acknowledgements</a>
<li><a href="#Links">References &amp; Links</a>
<li><a href="#Copyright">Copyright</a>
</ul>

<!--========================================================================-->
<h1><a name="Abstract">Abstract</a></H1>
<p>

<abbr title="Revised<sup>5</sup> Report on Scheme"><a href="#R5RS">R5RS</a></abbr>
Scheme has an impoverished set of string-processing utilities, which is a
problem for authors of portable code. Although
<abbr title="Revised<sup>7</sup> Report on Scheme"><a href="#R7RS">R7RS</a></abbr>
provides some extensions and improvements, it is still very incomplete.
This <abbr title="Scheme Request for
Implementation">SRFI</abbr> proposes a coherent and comprehensive set of
string-processing procedures; it is accompanied by a portable sample implementation
of the spec.
<p>This SRFI is derived from SRFI 13.  The biggest difference is that it
allows subsequences of strings to be specified by
<em>cursors</em> as well as the traditional string indexes.
In addition, it omits the comparison, case-mapping, and mutation operations
of SRFI 13, as well as all procedures already present in
<abbr title="Revised<sup>7</sup> Report on Scheme"><a href="#R7RS">R7RS</a></abbr>.

<!--========================================================================-->
<h1><a name="ProcedureIndex">Procedure Index</a></h1>
<p>
Here is a list of the procedures provided by this SRFI.
<div class=indent>
<dl>

<dt class=proc-index> Cursor operations
<dd class=proc-index>
<pre class=proc-index>
<a href="#string-cursor-p">string-cursor?</a>
<a href="#string-cursor-start">string-cursor-start</a>    <a href="#string-cursor-end">string-cursor-end</a>
<a href="#string-cursor-next">string-cursor-next</a>     <a href="#string-cursor-prev">string-cursor-prev</a>
<a href="#string-cursor-forward">string-cursor-forward</a>  <a href="#string-cursor-back">string-cursor-back</a>
<a href="#string-cursor-eq">string-cursor=?</a>
<a href="#string-cursor-lt">string-cursor&lt;?</a>        <a href="#string-cursor-gt">string-cursor>?</a>
<a href="#string-cursor-le">string-cursor&lt;=?</a>       <a href="#string-cursor-ge">string-cursor>=?</a>
<a href="#string-cursor-diff">string-cursor-diff</a>
<a href="#string-cursor2index">string-cursor->index</a>   <a href="#string-index2cursor">string-index->cursor</a>
</pre>

<dt class=proc-index> Predicates
<dd class=proc-index>
<pre class=proc-index>
<a href="#string-null-p">string-null?</a> 
<a href="#string-every">string-every</a> <a href="#string-any">string-any</a>
</pre>

<dt class=proc-index> Constructors
<dd class=proc-index>
<pre class=proc-index>
<a href="#string-tabulate">string-tabulate</a>
<a href="#string-unfold">string-unfold</a>   <a href="#string-unfold-right">string-unfold-right</a>
</pre>

<dt class=proc-index> Conversion
<dd class=proc-index>
<pre class=proc-index>
<a href="#string2list-w-cursors">string->list/cursors</a> <a href="#string2vector-w-cursors">string->vector/cursors</a>
<a href="#reverse-list2string">reverse-list->string</a> <a href="#string-join">string-join</a>
</pre>

<dt class=proc-index> Selection
<dd class=proc-index>
<pre class=proc-index>
<a href="#string-ref-w-cursor">string-ref/cursor</a>
<a href="#substring-w-cursors">substring/cursors</a>  <a href="#string-copy-w-cursors">string-copy/cursors</a>
<a href="#string-take">string-take</a>        <a href="#string-take-right">string-take-right</a>
<a href="#string-drop">string-drop</a>        <a href="#string-drop-right">string-drop-right</a>
<a href="#string-pad">string-pad</a>         <a href="#string-pad-right">string-pad-right</a> 
<a href="#string-trim">string-trim</a>        <a href="#string-trim-right">string-trim-right</a> <a href="#string-trim-both">string-trim-both</a>
</pre>

<dt class=proc-index>Prefixes &amp; suffixes
<dd class=proc-index>
<pre class=proc-index>
<a href="#string-prefix-length">string-prefix-length</a>    <a href="#string-suffix-length">string-suffix-length</a>
<a href="#string-prefix-p">string-prefix?</a>          <a href="#string-suffix-p">string-suffix?</a>    
</pre>

<dt class=proc-index>Searching
<dd class=proc-index>
<pre class=proc-index>
<a href="#string-index">string-index</a>     <a href="#string-index-right">string-index-right</a>
<a href="#string-skip">string-skip</a>      <a href="#string-skip-right">string-skip-right</a>
<a href="#string-contains">string-contains</a>  <a href="#string-contains-right">string-contains-right</a>
</pre>

<dt class=proc-index>The whole string
<dd class=proc-index>
<pre class=proc-index>
<a href="#string-reverse">string-reverse</a>
<a href="#string-concatenate">string-concatenate</a>  <a href="#string-concatenate-reverse">string-concatenate-reverse</a>
<a href="#string-fold">string-fold</a>         <a href="#string-fold-right">string-fold-right</a>
<a href="#string-for-each-cursor">string-for-each-cursor</a>
<a href="#string-replicate">string-replicate</a>    <a href="#string-count">string-count</a>
<a href="#string-replace">string-replace</a>      <a href="#string-split">string-split</a>
<a href="#string-filter">string-filter</a>       <a href="#string-remove">string-remove</a> 
</pre>


</dl>
</div>

<!--========================================================================-->
<h1><a name="Rationale">Rationale</a></h1>
<p>

This SRFI defines a rich set of operations for
manipulating strings. These are frequently useful for scripting and other
text-manipulation applications. The library's design was influenced by the
string libraries found in MIT Scheme, Gambit, RScheme, MzScheme, SLIB, Common
Lisp, Bigloo, Guile, Chez, APL, Java, and the SML standard basis.
All functionality is available in substring and full-string forms.

<p>
When SRFI 13 was defined in 1999, it was intended to provide efficient string operations
on both whole strings and substrings.  At that time, it was normal for strings to be
sequences of 8-bit characters, or in a few cases, characters of other fixed lengths.
Consequently, many of the SRFI 13 procedures accept optional exact integer
arguments for each of the string arguments, indexing the beginning and the end
of the substring(s) to be operated on.</p>

<p>
Unfortunately for this design, Unicode has become much more widely used, and it is now
fairly common for implementations to store strings internally as UTF-8 or UTF-16 code
unit sequences, which means that indexing operations are potentially O(n) rather than O(1).
Using opaque cursors makes it possible to iterate much more efficiently through such strings
compared to incrementing or decrementing indexes; however, for backward compatibility,
the procedures defined in this SRFI accept either cursors or indexes.
The results returned are always cursors: the use of indexes is
preserved mainly for the sake of existing code and for implementer
convenience.</p>
<p>
The operations provided here are entirely independent of the character repertoire supported
by the implementation.  In particular, this means that the comparison and case conversion
procedures of SRFI 13 are excluded.  There is also no provision for
<a class="ext-link" href="http://www.r6rs.org/final/html/r6rs-lib/r6rs-lib-Z-H-2.html#node_idx_54">R6RS normalization procedures</a>
or for a <code>string-&gt;integer</code> procedure that was proposed for SRFI 13 but not included.  These may appear in future SRFIs.
Furthermore, string mutation can be
extremely expensive if the storage used for the string needs to be expanded, particularly
if the implementation does not use an indirect pointer to it (as in Chicken),
so this SRFI does not provide for it.
The low-level procedures of SRFI 13 are specific to the sample implementation, and have been removed
to make other implementations simpler and easier.</p>
<p>Many SRFI 13 procedures accept either a predicate, a single character, or a
<a href="https://srfi.schemers.org/srfi-14/srfi-14.html">SRFI 14</a> character set.
In this SRFI, only support for predicates is required, though implementations may also support the
other two alternatives.  In that case, a single character is interpreted as a predicate which returns true if its
argument is the same (in the sense of <code>eqv?</code>) to that character; a character set is interpreted
as a predicate which returns true if its argument belongs to that character set.
In SRFI 13, character sets are inherently more efficient than predicates
<a class="ext-link" href="https://srfi.schemers.org/srfi-13/mail-archive/msg00052.html">
because testing them is fast and free of side effects</a>,
though how fast character sets actually are if they support full Unicode is very implementation-dependent.
The only procedure that absolutely requires character set support, <code>string-tokenize</code>,
has been replaced here by the more usual <code>string-split</code> procedure provided by Perl,
Python, Java, JavaScript, and other languages.
</p>
<p>The search procedures in SRFI 13 return either an index or <code>#f</code> if the search fails.
Their counterparts in this SRFI return cursors.  Left-to-right searches return a cursor representing
the leftmost matching character, or the post-end cursor if there is no match; right-to-left searches
return a cursor representing the <i>successor</i> of the rightmost matching character, or the
start cursor if there is no match.  This convention was devised by Alan Watson
and implemented in Chibi Scheme.</p>
<p>
In short, this SRFI is intended to help move the practice of Scheme programming
away from mutable strings, string indexes, and SRFI 13, while largely maintaining 
backward compatibility.  It does not require any particular run-time efficiencies from its procedures.


<!--========================================================================-->
<h1><a name="Specification">Specification</a></h1>




<!--========================================================================-->
<h2><a name="StringCursors">String cursors</a></h2>
<p>
 While indexes are exact integers
ranging from 0 to the length of the string they refer to, cursors are opaque objects
that point into strings.
However, they are not required to belong to a disjoint type, as long as they are either disjoint
from indexes or identical to indexes.  For example, they may be negative exact integers representing
indexes into a byte array underlying the string.  It is also possible to implement cursors as a record type
or an implementation-specific primitive type.
Additionally, in implementations where no provision has been made for cursors, or there is no benefit in
implementing them separately because strings are in fact arrays of fixed-length characters, it is useful
to allow indexes and cursors to be the same thing.
(Cursors must also be disjoint from <code>#f</code>.)

<p>It is an error to make any use of a cursor referring to a string after
the string, or any string that shares storage with it, has been mutated by a procedure like <code>string-set!</code>,
<code>string-copy!</code>, or <code>string-fill!</code>.

<p>
Given a string of length <em>n</em>, there are <em>n</em> + 1 valid cursors
that refer to it: one for each character in the string,
and one for the position just after the last character, known as the "post-end cursor".
The cursor for the first (or zeroth) position in the string is known as the "start cursor".
The post-end cursor is provided because
when creating a string from cursors the second cursor argument is exclusive.
It is an error if a cursor argument is not one of the valid cursors for the string argument.
The index analogue of the post-end cursor is <em>n</em>.
</p>

<h2><a name="CallingPredicates">Calling predicates</a></h2>

<p>
All predicates passed to procedures defined in this SRFI may be called in any order
and any number of times, except as otherwise noted.  This is not the case in SRFI 13.

<!--========================================================================-->
<h2><a name="SharedStorage">Shared storage</a></h2>

<p>
Some Scheme implementations, <em>e.g.</em> Guile, provide ways to construct
substrings that share storage with other strings. SRFI 130 provides only
minimal support for such shared substrings.  The following SRFI 130 procedures
are allowed to return
a result which shares storage with one or more of their string arguments:
<pre>
    substring/cursors
    string-take string-take-right
    string-drop string-drop-right
    string-pad string-pad-right
    string-trim string-trim-right string-trim-both
    string-split string-filter string-remove
</pre>

<p>In particular, if the result is the same (in the sense of <code>string=?</code>)
as any of the arguments, <i>any</i> implementation of the above procedures may return
the string argument
without copying it. Other procedures such as 
<code>string-copy/cursors</code>, as well as all the
<abbr title="Revised<sup>7</sup> Report on Scheme"><a href="#R7RS">R7RS</a></abbr> procedures,
are not permitted to return shared results.
If a shared value is returned, it may be mutable or immutable.


<!--========================================================================-->
<h2><a name="NamingConventions">Naming conventions</a></h2>

<p>
The procedures of this SRFI follow
a consistent naming scheme, and are consistent with the conventions
developed in SRFI 1. The names are composed of smaller lexemes
in a regular way that exposes the structure and relationships between the
procedures. This should help the programmer to recall or reconstitute the name
of the desired procedure.  In
particular, the order of common parameters is consistent across the
different procedures.
<p>Procedures that have left/right directional variants
use no suffix to specify left-to-right operation, <code>-right</code> to specify
right-to-left operation, and <code>-both</code> to specify both.
This is a general convention that has been established in other SRFIs;
the value of a convention is proportional to the extent of its use.
</ul>
      
<!--========================================================================-->
<h2><a name="Notation">Notation</a></h2>
<p>
In the following procedure specifications:
<ul>
    <li><p> An <var>s</var> parameter is a string.

    <li><p> A <var>char</var> parameter is a character.

    <li><p> <var>Start</var> and <var>end</var> parameters are half-open string
      cursors or indexes specifying 
      a substring within a string parameter, and typically restrict a procedure's
      action to the indicated substring.  When omitted, they default
      to 0 and the length of the string, respectively; or from another
      point of view, they default to the start cursor
      and the post-end cursor, respectively. For indexes, it
      must be the case that 0 &lt;= <var>start</var> &lt;= <var>end</var> 
      &lt;= <code>(string-length <var>s</var>)</code>, for
      the corresponding parameter <var>s</var> when <var>start</var>
      and <var>end</var> are indexes, and the corresponding relationship
      must hold when they are cursors.  It is an error unless <var>start</var>
      and <var>end</var> are both cursors or both indexes.

    <li><p> A <var>pred</var> parameter is a unary character predicate procedure, returning 
      a true/false value when applied to a character.  It is an error if a <var>pred</var>
      is not pure and functional.

    <li><p> A <var>cursor</var> parameter is either a cursor or an exact non-negative integer
    specifying an index into a string.
    
    <li><p> <var>Len</var> and <var>nchars</var> parameters are exact non-negative integers specifying a
      length of a string or some number of characters.

    <li><p> An <var>obj</var> parameter may be any value at all.
</ul>
<p class=continue>
Passing values to procedures with these parameters that do not satisfy these
types is an error.

<p>
Parameters given in square brackets are optional. Unless otherwise noted in the
text describing the procedure, any prefix of these optional parameters may
be supplied, from zero arguments to the full list. When a procedure returns
multiple values, this is shown by listing the return values in square
brackets, as well. So, for example, the procedure with signature
<pre class=code-example>
halts? <var>f [x init-store]</var> → <var>[boolean integer]</var>
</pre>
would take one (<var>f</var>), two (<var>f</var>, <var>x</var>) 
or three (<var>f</var>, <var>x</var>, <var>init-store</var>) input parameters, 
and return two values, a boolean and an integer.

<p>
A parameter followed by "<code>...</code>" means zero or more elements. 
So the procedure with the signature
<pre class=code-example>
sum-squares <var>x ... </var> → <var>number</var>
</pre>
takes zero or more arguments (<var>x ...</var>), 
while the procedure with signature
<pre class=code-example>
spell-check <var>doc dict<sub>1</sub> dict<sub>2</sub> ...</var> → <var>string-list</var>
</pre>
takes two required parameters 
(<var>doc</var> and <var>dict<sub>1</sub></var>) 
and zero or more optional parameters (<var>dict<sub>2</sub> ...</var>).

<p>
If a procedure's return value is said to be "unspecified," this means that the procedure
returns a single arbitrary value. Such a procedure is not even
required to be consistent from call to call. 
<!--========================================================================-->
<h2><a name="Procedures">Procedures</a></h2>


<!--========================================================================-->
<h3><a name="CursorOperations">Cursor operations</a></h3>
<p>These procedures are mostly taken from Chibi Scheme.

<dl>
<!--
==== string-cursor?
============================================================================-->
<dt class=proc-def1>
<a name="string-cursor-p"></a>
<code class=proc-def>string-cursor?</code><var> obj → boolean</var>
<dd class=proc-def>
    Returns <code>#t</code> if <var>obj</var> can be a string cursor,
    and <code>#f</code> otherwise.  In implementations where cursors
    and indexes are the same thing, <code>#t</code> is returned on
    any cursor or index; where they are disjoint, <code>#t</code> is
    returned on cursors, <code>#f</code> on indexes.  If <var>obj</var>
    is neither a cursor nor an index, <code>string-cursor?</code> will
    always return <code>#f</code>.
</dd>

<dl>
<!--
==== string-cursor-start string-cursor-end
============================================================================-->
<dt class=proc-def1>
<a name="string-cursor-start"></a>
<a name="string-cursor-end"></a>
<code class=proc-def>string-cursor-start</code><var> s → cursor</var>
<dt class=proc-defn><code class=proc-def>string-cursor-end</code><var> s → cursor</var>
<dd class=proc-def>
    Returns the start/post-end cursor of <var>s</var> respectively.
</dd>

<!--
==== string-cursor-next string-cursor-prev
============================================================================-->
<dt class=proc-def1>
<a name="string-cursor-next"></a>
<a name="string-cursor-prev"></a>
<code class=proc-def>string-cursor-next</code><var> s cursor → cursor</var>
<dt class=proc-defn><code class=proc-def>string-cursor-prev</code><var> s cursor → cursor</var>
<dd class=proc-def>
    Returns the cursor into <var>s</var> following/preceding <var>cursor</var>.
    If <var>cursor</var> is an index, returns one more/less than <var>cursor</var>.
    It is an error if <var>cursor</var> is the post-end/start cursor of <var>s</var>.
</dd>

<!--
==== string-cursor-forward string-cursor-back
============================================================================-->
<dt class=proc-def1>
<a name="string-cursor-forward"></a>
<a name="string-cursor-back"></a>
<code class=proc-def>string-cursor-forward</code><var> s cursor nchars → cursor</var>
<dt class=proc-defn><code class=proc-def>string-cursor-back</code><var> s cursor nchars → cursor</var>
<dd class=proc-def>
    Returns the cursor into <var>s</var> which follows/precedes <var>cursor</var>
    by <var>nchars</var> characters.
    If <var>cursor</var> is an index, returns <var>nchars</var> more/less than <var>cursor</var>.
    It is an error if the result would be an invalid cursor or index.
</dd>

<!--
==== string-cursor comparisons
============================================================================-->
<dt class=proc-def1>
<a name="string-cursor-eq"></a>
<a name="string-cursor-lt"></a>
<a name="string-cursor-gt"></a>
<a name="string-cursor-le"></a>
<a name="string-cursor-ge"></a>
<code class=proc-def>string-cursor=?</code><var> cursor<sub>1</sub> cursor<sub>2</sub> → boolean</var>
<dt class=proc-defi><code class=proc-def>string-cursor&lt;?</code><var> cursor<sub>1</sub> cursor<sub>2</sub> → boolean</var>
<dt class=proc-defi><code class=proc-def>string-cursor>?</code><var> cursor<sub>1</sub> cursor<sub>2</sub> → boolean</var>
<dt class=proc-defi><code class=proc-def>string-cursor&lt;=?</code><var> cursor<sub>1</sub> cursor<sub>2</sub> → boolean</var>
<dt class=proc-defn><code class=proc-def>string-cursor>=?</code><var> cursor<sub>1</sub> cursor<sub>2</sub> → boolean</var>
<dd class=proc-def>
    Compares two cursors or two indexes pointing into the same string.

<!--
==== string-cursor-diff
============================================================================-->
<dt class=proc-def>
<a name="string-cursor-diff"></a>
<code class=proc-def>string-cursor-diff</code><var> s start end → nchars</var>
<dd class=proc-def>
    Returns the number of characters between <var>start</var> and <var>end</var>
    in string <var>s</var>.
    Note that the result is always non-negative if <var>start</var>
    and <var>end</var> are a valid start-end pair.
</dd>

<!--
==== string-cursor->index string-index->cursor
============================================================================-->
<dt class=proc-def1>
<a name="string-cursor2index"></a>
<a name="string-index2cursor"></a>
<code class=proc-def>string-cursor->index</code><var> s cursor → index</var>
<dt class=proc-defn><code class=proc-def>string-index->cursor</code><var> s index → cursor</var>
<dd class=proc-def>
    Converts a cursor/index into <var>s</var> into the corresponding
    index/cursor.  If the argument is already an index/cursor, it is
    returned unchanged.
</dd>

</dl>


<!--========================================================================-->
<h3><a name="Predicates">Predicates</a></h3>

<dl>
<!--
==== string-null?
============================================================================-->
<dt class=proc-def>
<a name="string-null-p"></a>
<code class=proc-def>string-null?</code><var> s → boolean</var>
<dd class=proc-def>
    Is <var>s</var> the empty string?
</dd>

<!--
==== string-every string-any
============================================================================-->
<dt class=proc-def1>
<a name="string-every"></a>
<a name="string-any"></a>
<code class=proc-def>string-every</code><var> pred s [start end] → value</var>
<dt class=proc-defn><code class=proc-def>string-any</code><var> pred s [start end] → value</var>
<dd class=proc-def>
    Checks to see if every/any character in <var>s</var> satisfies <var>pred</var>
    proceeding from left (index <var>start</var>) to right (index <var>end</var>).
    The predicate is "witness-generating":

    <ul>
      <li> If <code>string-any</code> returns true, the returned true value is the one produced
        by the application of the predicate.
    
      <li> If <code>string-every</code> returns true, the returned true value is the one
        produced by the final application of the predicate to <var>s</var>[<var>end</var>-1]. 
        If <code>string-every</code> is applied to an empty sequence of characters, 
        it simply returns <code>#t</code>.
    </ul>

<p>
    The names of these procedures do not end with a question mark — this is to
    indicate that they do not return a simple boolean
    (<code>#t</code> or <code>#f</code>), but a general value.
</dl>


<!--========================================================================-->
<h3><a name="Constructors">Constructors</a></h3>

<dl>
<!--
==== string-tabulate
============================================================================-->
<dt class=proc-def>
<a name="string-tabulate"></a>
<code class=proc-def>string-tabulate</code><var> proc len → string</var>
<dd class=proc-def>
    <var>Proc</var> is an integer → char procedure. Construct a string of size <var>len</var>
    by applying <var>proc</var> to each value from 0 (inclusive) to <var>len</var> (exclusive) to produce the corresponding string
    element. The order in which <var>proc</var> is applied to the indexes is not
    specified.
  <p>Note that the order of arguments is not the same as SRFI 1's
     <code>list-tabulate</code>, but is the same as tabulation functions
     in other SRFIs.  When this discrepancy was discovered in SRFI 13,
     it was too late to change SRFI 1.


<!--
==== string-unfold
============================================================================-->
<dt class=proc-def>
<a name="string-unfold"></a>
<code class=proc-def>string-unfold</code><var> stop? mapper successor seed [base make-final] → string</var>
<dd class=proc-def>
This is a fundamental constructor for strings. 
<ul>
<li> <var>Successor</var> is used to generate a series of "seed" values from the initial seed:
<div class=inset>
    <var>seed</var>, (<var>successor</var> <var>seed</var>), (<var>successor<sup>2</sup></var> <var>seed</var>), (<var>successor<sup>3</sup></var> <var>seed</var>), ...
</div>
<li> <var>Stop?</var> tells us when to stop — when it returns true when applied to one 
  of these seed values.
<li> <var>Mapper</var> maps each seed value to the corresponding character 
  in the result string. These chars are assembled into the
  string in a left-to-right order.
<li> <var>Base</var> is the optional initial/leftmost portion of the constructed string;
  it defaults to the empty string "".
<li> <var>Make-final</var> is applied to the terminal seed value (on which <var>stop?</var> returns
  true) to produce the final/rightmost portion of the constructed string.
  It defaults to <code>(lambda (x) "")</code>.
</ul>

<p>
<code>string-unfold</code> is a fairly powerful string constructor — you can use it to
convert a list to a string, read a port into a string, reverse a string,
copy a string, and so forth. Examples:
<pre class=code-example>
(port->string p) = (string-unfold eof-object? values
                                  (lambda (x) (read-char p))
                                  (read-char p))

(list->string lis) = (string-unfold null? car cdr lis)

(string-tabulate f size) = (string-unfold (lambda (i) (= i size)) f add1 0)
</pre>
<p>
To map <var>f</var> over a list <var>lis</var>, producing a string:
<pre class=code-example>
(string-unfold null? (compose f car) cdr lis)
</pre>
<p>
Interested functional programmers may enjoy noting that 
<code>string-fold-right</code> 
and <code>string-unfold</code> are in some sense inverses. That is, given operations 
<var>knull?</var>, <var>kar</var><var>, kdr</var>, <var>kons</var>, and <var>knil</var> satisfying
<pre class=code-example>
(<var>kons</var> (<var>kar</var> x) (<var>kdr</var> x)) = x  and (<var>knull?</var> <var>knil</var>) = #t
</pre>
then
<pre class=code-example>
(string-fold-right <var>kons</var> <var>knil</var> (string-unfold <var>knull?</var> <var>kar</var> <var>kdr</var> <var>x</var>)) = <var>x</var>
</pre>
and
<pre class=code-example>
(string-unfold <var>knull?</var> <var>kar</var> <var>kdr</var> (string-fold-right <var>kons</var> <var>knil</var> <var>s</var>)) = <var>s</var>.
</pre>

The final string constructed does not share storage with either <var>base</var>
or the value produced by <var>make-final</var>.

<p>
This combinator sometimes is called an "anamorphism."

<p>
Note: implementations should take care that runtime stack limits do not
cause overflow when constructing large (<em>e.g.</em>, megabyte) strings with
<code>string-unfold</code>.


<!--
==== string-unfold-right
============================================================================-->
<dt class=proc-def>
<a name="string-unfold-right"></a>
<code class=proc-def>string-unfold-right</code><var> stop? mapper successor seed [base make-final] → string</var>
<dd class=proc-def>
    This is a fundamental constructor for strings.  It is equivalent to <code>string-unfold</code>,
    except that the results of <var>mapper</var> are assembled into the
    string in a right-to-left order, <var>base</var> is the optional rightmost portion
    of the constructed string, and <var>make-final</var>
    produces the leftmost portion of the constructed string.

</dl>

<h3><a name="Conversion">Conversion</a></h3>
          
<dl>

<!--
==== string->list/cursors string->vector/cursors
============================================================================-->
<dt class=proc-def1>
<a name="string2list-w-cursors"></a>
<a name="string2vector-w-cursors"></a>
<code class=proc-def>string-&gt;list/cursors</code><var> s [start end] → char-list</var>
<dt class=proc-defn><code class=proc-def>string-&gt;vector/cursors</code><var> s [start end] → char-vector</var>
<dd class=proc-def>
    <code>string->list/cursors</code> and <code>string->vector/cursors</code> return
    a newly allocated list or vector of the characters
    that make up the given string.  They differ from the
    <abbr title="Revised<sup>7</sup> Report on Scheme"><a href="#R7RS">R7RS</a></abbr> procedures
    <code>string->list</code> and <code>string->vector</code>
    by accepting either cursors or indexes.
<!--
==== reverse-list->string
============================================================================-->
<dt class=proc-def>
<a name="reverse-list2string"></a>
<code class=proc-def>reverse-list-&gt;string</code><var> char-list → string</var>
<dd class=proc-def>
    An efficient implementation of <code>(compose list->string reverse)</code>:
<pre class=code-example>
(reverse-list->string '(#\a #\B #\c)) → "cBa"
</pre>
    This is a common idiom in the epilog of string-processing loops
    that accumulate an answer in a reverse-order list. (See also
    <code>string-concatenate-reverse</code> for the "chunked" variant.)

<!--
==== string-join
============================================================================-->
<dt class=proc-def>
<a name="string-join"></a>
<code class=proc-def>string-join</code><var> string-list [delimiter grammar] → string</var>
<dd class=proc-def>
    This procedure is a simple unparser —- it pastes strings together using
    the delimiter string. 

    <p>
    The <var>grammar</var> argument is a symbol that determines how the delimiter is
    used, and defaults to <code>'infix</code>.
    
<ul>
      <li> <code>'infix</code> means an infix or separator grammar: 
        insert the delimiter
        between list elements.  An empty list will produce an empty string —
        note, however, that parsing an empty string with an infix or separator
        grammar is ambiguous. Is it an empty list, or a list of one element,
        the empty string?
    
      <li> <code>'strict-infix</code> means the same as <code>'infix</code>, 
        but will signal an error if given an empty list.
    
      <li> <code>'suffix</code> means a suffix or terminator grammar: 
        insert the delimiter
        after every list element. This grammar has no ambiguities.

      <li> <code>'prefix</code> means a prefix grammar: insert the delimiter
        before every list element. This grammar has no ambiguities.
</ul>

    The delimiter is the string used to delimit elements; it defaults to
    a single space "&nbsp;".
<pre class=code-example>
(string-join '("foo" "bar" "baz") ":")         =&gt; "foo:bar:baz"
(string-join '("foo" "bar" "baz") ":" 'suffix) =&gt; "foo:bar:baz:"

;; Infix grammar is ambiguous wrt empty list vs. empty string,
(string-join '()   ":") =&gt; ""
(string-join '("") ":") =&gt; ""

;; but suffix &amp; prefix grammars are not.
(string-join '()   ":" 'suffix) =&gt; ""
(string-join '("") ":" 'suffix) =&gt; ":"
</pre>
</dl>


<!--========================================================================-->
<h3><a name="Selection">Selection</a></h3>

<dl>
<!--
==== string-ref/cursor
============================================================================-->
<dt class=proc-def>
<a name="string-ref-w-cursor"></a>
<code class=proc-def>string-ref/cursor</code><var> s cursor → char</var>
<dd class=proc-def>
  Returns character <var>s[i]</var> using a valid cursor or index of <var>s</var>.  
  It differs from the
    <abbr title="Revised<sup>7</sup> Report on Scheme"><a href="#R7RS">R7RS</a></abbr> procedure <code>string-ref</code>
    by accepting either a cursor or an index.
<!--
==== string-copy substring/cursors
============================================================================-->
<dt class=proc-def1>
<a name="substring-w-cursors"></a>
<a name="string-copy-w-cursors"></a>
<code class=proc-def>substring/cursors</code><var>        s  start end → string</var>
<dt class=proc-defn><code class="proc-def">string-copy/cursors</code><var>      s [start end] → string</var>
<dd class=proc-def>
    These procedures return a string whose contents are the characters of <var>s</var>
    beginning with index <var>start</var> (inclusive) and ending with index <var>end</var>
    (exclusive).
    If <code>substring/cursors</code> produces the entire string, it may return either
    <var>s</var> or a copy of <var>s</var>; in some implementations, proper substrings may share
    memory with <var>s</var>.
    However, <code>string-copy/cursors</code> always returns a newly allocated string.
    They differ from the
    <abbr title="Revised<sup>7</sup> Report on Scheme"><a href="#R7RS">R7RS</a></abbr> procedures
    <code>substring</code> and <code>string-copy</code>
    by accepting either cursors or indexes.

<!--
==== string-take string-drop string-take-right string-drop-right
============================================================================-->
<dt class=proc-def1>
<a name="string-take"></a>
<a name="string-drop"></a>
<a name="string-take-right"></a>
<a name="string-drop-right"></a>
<code class=proc-def>string-take</code><var> s nchars → string</var>
<dt class=proc-defi><code class=proc-def>string-drop</code><var> s nchars → string</var>
<dt class=proc-defi><code class=proc-def>string-take-right</code><var> s nchars → string</var>
<dt class=proc-defn><code class=proc-def>string-drop-right</code><var> s nchars → string</var>
<dd class=proc-def>
    <code>string-take</code> returns the first <var>nchars</var> of <var>s</var>; 
    <code>string-drop</code> returns all but the first <var>nchars</var> of <var>s</var>.
    <code>string-take-right</code> returns the last <var>nchars</var> of <var>s</var>;
    <code>string-drop-right</code> returns all but the last <var>nchars</var> of <var>s</var>.
    If these procedures produce the entire string, they may return either
    <var>s</var> or a copy of <var>s</var>; in some implementations, proper substrings may share
    memory with <var>s</var>.
<pre class=code-example>
(string-take "Pete Szilagyi" 6) =&gt; "Pete S"
(string-drop "Pete Szilagyi" 6) =&gt; "zilagyi"

(string-take-right "Beta rules" 5) =&gt; "rules"
(string-drop-right "Beta rules" 5) =&gt; "Beta "
</pre>

    It is an error to take or drop more characters than are in the string:
<pre class=code-example>
(string-take "foo" 37) =&gt; <em>error</em>
</pre>

<!--
==== string-pad string-pad-right
============================================================================-->
<dt class=proc-def1>
<a name="string-pad"></a>
<a name="string-pad-right"></a>
<code class=proc-def>string-pad</code><var>       s len [char start end] → string</var>
<dt class=proc-defn><code class=proc-def>string-pad-right</code><var> s len [char start end] → string</var>
<dd class=proc-def>
    Build a string of length <var>len</var> comprised of <var>s</var> padded on the left (right)
    by as many occurrences of the character <var>char</var> as needed. If <var>s</var> has more
    than <var>len</var> chars, it is truncated on the left (right) to length <var>len</var>. <var>Char</var>
    defaults to <code>#\space</code>.

    <p>
    If <var>len</var> &lt;= <var>end</var>-<var>start</var>, the returned value is allowed to share storage
    with <var>s</var>, or be exactly <var>s</var> (if <var>len</var> = <var>end</var>-<var>start</var>).
<pre class=code-example>
(string-pad     "325" 5) =&gt; "  325"
(string-pad   "71325" 5) =&gt; "71325"
(string-pad "8871325" 5) =&gt; "71325"
</pre>

<!--
==== string-trim string-trim-right string-trim-both
============================================================================-->
<dt class=proc-def1>
<a name="string-trim"></a>
<a name="string-trim-right"></a>
<a name="string-trim-both"></a>
<code class=proc-def>string-trim&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</code><var> s [pred start end] → string</var>
<dt class=proc-defi><code class=proc-def>string-trim-right</code><var> s [pred start end] → string</var>
<dt class=proc-defi><code class=proc-def>string-trim-both&nbsp;</code><var> s [pred start end] → string</var>
<dd class=proc-defn>
    Trim <var>s</var> by skipping over all characters on the left / on the right /
    on both sides that satisfy the second parameter <var>pred</var>:
    <var>pred</var> defaults to  <code>char-whitespace?</code>.

    <p>
    If no trimming occurs, these functions may return either <var>s</var> or a copy of <var>s</var>;
    in some implementations, proper substrings may share memory with <var>s</var>.

<pre class=code-example>
(string-trim-both "  The outlook wasn't brilliant,  \n\r")
    =&gt; "The outlook wasn't brilliant,"
</pre>
</dl>


<!--========================================================================-->
<h3><a name="PrefixesSuffixes">Prefixes &amp; suffixes</a></h3>

<dl>
<!--
==== string-prefix-length    string-suffix-length
============================================================================-->
<dt class=proc-def1>
<a name="string-prefix-length"></a>
<a name="string-suffix-length"></a>
<code class=proc-def>string-prefix-length&nbsp;&nbsp;&nbsp;</code><var> s1 s2 [start1 end1 start2 end2] → integer</var>
<dt class=proc-defn><code class=proc-def>string-suffix-length&nbsp;&nbsp;&nbsp;</code><var> s1 s2 [start1 end1 start2 end2] → integer</var>
<dd class=proc-def>
Return the length of the longest common prefix/suffix of the two strings.
For prefixes, this is equivalent to the "mismatch index" for the strings
(modulo the start cursors).

<p>
The optional start/end cursors or indexes restrict the comparison to the indicated
substrings of <var>s1</var> and <var>s2</var>.


<!--
==== string-prefix? string-suffix? 
============================================================================-->
<dt class=proc-def1>
<a name="string-prefix-p"></a>
<a name="string-suffix-p"></a>
<a name="string-prefix-ci-p"></a>
<a name="string-suffix-ci-p"></a>
<code class=proc-def>string-prefix?&nbsp;&nbsp;&nbsp;</code><var> s1 s2 [start1 end1 start2 end2] → boolean</var>
<dt class=proc-defn><code class=proc-def>string-suffix?&nbsp;&nbsp;&nbsp;</code><var> s1 s2 [start1 end1 start2 end2] → boolean</var>
<dd class=proc-def>
Is <var>s1</var> a prefix/suffix of <var>s2</var>?

<p>
The optional start/end cursors or indexes restrict the comparison to the indicated
substrings of <var>s1</var> and <var>s2</var>.


</dl>

<!--========================================================================-->
<h3><a name="Searching">Searching</a></h3>

<dl>

<!--
==== string-index string-index-right string-skip string-skip-right
============================================================================-->
<dt class=proc-def1>
<a name="string-index"></a>
<a name="string-index-right"></a>
<a name="string-skip"></a>
<a name="string-skip-right"></a>
<code class=proc-def>string-index</code><var>       s pred [start end] → cursor</var>
<dt class=proc-defi><code class=proc-def>string-index-right</code><var> s pred [start end] → cursor</var>
<dt class=proc-defi><code class=proc-def>string-skip</code><var> s pred [start end] → cursor</var>
<dt class=proc-defn><code class=proc-def>string-skip-right</code><var> s pred [start end] → cursor</var>
<dd class=proc-def>
<code>string-index</code> searches through <var>s</var> from the 
left, returning the cursor of the first occurrence of a character 
which satisfies the predicate <var>pred</var>.
If no match is found, it returns <var>end</var>.
<code>string-index-right</code> searches through <var>s</var> from the 
right, returning the cursor of the <i>successor</i> of the first occurrence of a character 
which satisfies the predicate <var>pred</var>.
If no match is found, it returns <var>start</var>.

<p>
The <var>start</var> and <var>end</var> parameters specify the beginning and end cursors or indexes of
the search; the search includes the start, but not the end.
Be careful of "fencepost" considerations: when searching right-to-left, 
the first position considered is
    <code>(string-cursor-prev <var>end</var>)</code>,
whereas when searching left-to-right, the first index considered is
      <var>start</var>.
That is, the start/end indexes describe the same half-open interval
[<var>start</var>,<var>end</var>) in these procedures that they do
in all the other SRFI 130 procedures.

<p>
The skip functions are similar, but use the complement of the criteria:
they search for the first char that <em>doesn't</em> satisfy <var>pred</var>. <em>E.g.</em>, 
to skip over initial whitespace, say
<pre class=code-example>
(substring/cursors s (string-skip s char-whitespace?))
</pre>
<p>Note that the result is always a cursor, even when <var>start</var> and <var>end</var>
are indexes.  Use <code>string-cursor->index</code> to convert the result to an index.
Therefore, these four functions are not entirely compatible with their
SRFI 13 counterparts, which return <code>#f</code> on failure.</p>
<p>These functions can be trivially composed with <code>string-take</code> and
<code>string-drop</code> to produce take-while, drop-while, span, and break
procedures without loss of efficiency.</p>
<!--
==== string-contains string-contains-right
============================================================================-->
<dt class=proc-def1>
<a name="string-contains"></a>
<a name="string-contains-right"></a>
<code class=proc-def>string-contains </code><var> s1 s2 [start1 end1 start2 end2] → cursor</var>
<dt class=proc-defn><code class=proc-def>string-contains-right </code><var> s1 s2 [start1 end1 start2 end2] → cursor</var>
<dd class=proc-def>
Does string <var>s1</var> contain string <var>s2</var>?

<p>
Returns the cursor in <var>s1</var> referring to the first character of the first/last
instance of <var>s2</var>  as a substring, or <code>#f</code> if there is no match.
The optional start/end indexes restrict the operation to the
indicated substrings.

<p>
The returned cursor is in the range [<var>start1</var>,<var>end1</var>). 
A successful match must lie entirely in the 
[<var>start1</var>,<var>end1</var>) range of <var>s1</var>.
<p>Note that the result is always a cursor, even when <var>start1</var> and <var>end1</var>
are indexes.<br />Use <code>string-cursor->index</code> to convert a cursor result to an index.</p>

<p>
<pre class=code-example>
(string-contains "eek -- what a geek." "ee"
                 12 18) ; Searches "a geek"
    =&gt; {Cursor 15}
</pre>


<p>
The name of this procedure does not end with a question mark — this is to
indicate that it does not return a simple boolean (<code>#t</code> or <code>#f</code>). Rather,
it returns either false (<code>#f</code>) or a cursor.

</dl>

<!--========================================================================-->
<h3><a name="TheWholeString">The whole string</a></h3>

<dl>

<!--
==== string-reverse
============================================================================-->
<dt class=proc-def>
<a name="string-reverse"></a>
<code class=proc-def>string-reverse&nbsp;</code><var> s [start end] -> string</var>
<dd class=proc-def>
Reverse the string.

<p>
<code>string-reverse</code> returns the result string 
and does not alter its <var>s</var> parameter. 

<pre class=code-example>
(string-reverse "Able was I ere I saw elba.") 
    =&gt; ".able was I ere I saw elbA"
(string-reverse "Who stole the spoons?" 14 20)
    =&gt; "snoops"

</pre>

<p>
Unicode note: Reversing a string simply reverses the sequence of
code-points it contains. So a combining diacritic <var>a</var> 
coming <em>after</em> a base character <var>b</var> in string <var>s</var> 
would come out <em>before</em> <var>b</var> in the reversed result.
<!--
==== string-concatenate
============================================================================-->
<dt class=proc-def>
<a name="string-concatenate"></a>
<code class=proc-def>string-concatenate</code><var> string-list → string</var>
<dd class=proc-def>
    Append the elements of <code>string-list</code> together into a single string.
    Guaranteed to return a freshly allocated string.

    <p>
    Note that the <code>(apply string-append <var>string-list</var>)</code>
    idiom is
    not robust for long lists of strings, as some Scheme implementations
    limit the number of arguments that may be passed to an n-ary procedure.

<!--
==== string-concatenate-reverse
============================================================================-->
<dt class=proc-def1>
<a name="string-concatenate-reverse"></a>
<code class=proc-def>string-concatenate-reverse</code><var>        string-list [final-string end] → string</var>
<dd class=proc-def>
With no optional arguments, this function is equivalent to
<pre class=code-example>
(string-concatenate (reverse <var>string-list</var>))
</pre>


<p>
If the optional argument <var>final-string</var> is specified, it is consed
onto the beginning of <var>string-list</var>
before performing the list-reverse and string-concatenate operations.

</p>
If the optional argument <var>end</var> is given, 
only the characters up to but not including <var>end</var>
in <var>final-string</var> are added to the result, thus producing
<pre class=code-example>
(string-concatenate 
  (reverse (cons (substring <var>final-string</var>
                            (string-cursor-start <var>final-string</var>)
                            end)
                 <var>string-list</var>)))
</pre>
<em>E.g.</em>
<pre class=code-example>
(string-concatenate-reverse '(" must be" "Hello, I") " going.XXXX" 7)
  =&gt; "Hello, I must be going."
</pre>

<p>
This procedure is useful in the construction of procedures that 
accumulate character data into lists of string buffers, and wish to
convert the accumulated data into a single string when done.

<!--
==== string-fold string-fold-right
============================================================================-->
<dt class=proc-def1>
<a name="string-fold"></a>
<a name="string-fold-right"></a>
<code class=proc-def>string-fold</code><var>       kons knil s [start end] → value</var>
<dt class=proc-defn><code class=proc-def>string-fold-right</code><var> kons knil s [start end] → value</var>
<dd class=proc-def>
These are the fundamental iterators for strings.

<p>
The left-fold operator maps the <var>kons</var> procedure across the
string from left to right
<pre class=code-example>
(... (<var>kons</var> <var>s</var>[2] (<var>kons</var> <var>s</var>[1] (<var>kons</var> <var>s</var>[0] <var>knil</var>))))
</pre>
In other words, <code>string-fold</code> obeys the (tail) recursion
<pre class=code-example>
(string-fold <var>kons</var> <var>knil</var> <var>s</var> <var>start</var> <var>end</var>) =
    (string-fold <var>kons</var> (<var>kons</var> <var>s</var>[<var>start</var>] <var>knil</var>) <var>s</var> <var>start+1</var> <var>end</var>)
</pre>

<p>
The right-fold operator maps the <var>kons</var> procedure across the
string from right to left
<pre class=code-example>
(<var>kons</var> <var>s</var>[0] (... (<var>kons</var> <var>s</var>[<var>end-3</var>] (<var>kons</var> <var>s</var>[<var>end-2</var>] (<var>kons</var> <var>s</var>[<var>end-1</var>] <var>knil</var>)))))
</pre>
obeying the (tail) recursion
<pre class=code-example>
(string-fold-right <var>kons</var> <var>knil</var> <var>s</var> <var>start</var> <var>end</var>) =
    (string-fold-right <var>kons</var> (<var>kons</var> <var>s</var>[<var>end-1</var>] <var>knil</var>) <var>s</var> <var>start</var> <var>end-1</var>)
</pre>
    
<p>
Examples: 
<pre class=code-example>
;;; Convert a string to a list of chars.
(string-fold-right cons '() s)

;;; Count the number of lower-case characters in a string.
(string-fold (lambda (c count)
               (if (char-lower-case? c)
                   (+ count 1)
                   count))
             0
             s)

;;; Double every backslash character in S.
(let* ((ans-len (string-fold (lambda (c sum)
                               (+ sum (if (char=? c #\\) 2 1)))
                             0 s))
       (ans (make-string ans-len)))
  (string-fold (lambda (c i)
                 (let ((i (if (char=? c #\\)
                              (begin (string-set! ans i #\\) (+ i 1))
                              i)))
                   (string-set! ans i c)
                   (+ i 1)))
               0 s)
  ans)
</pre>

<p>
The right-fold combinator is sometimes called a "catamorphism."

<!--
==== string-for-each-cursor
============================================================================-->
<dt class=proc-def>
<a name="string-for-each-cursor"></a>
<code class=proc-def>string-for-each-cursor</code><var> proc s [start end] → unspecified</var>
<dd class=proc-def>
Apply <var>proc</var> to each cursor of <var>s</var>, in order, excluding the post-end cursor.  The optional <var>start/end</var>
pairs restrict the endpoints of the loop. This is simply a
method of looping over a string that is guaranteed to be safe
and correct.

Example:
<pre class=code-example>
(let ((s "abcde") (v '()))
  (string-for-each-cursor
    (lambda (cur) (set! v (cons (char->integer (string-ref/cursor s cur)) v)))
    s)
  v) =&gt; (101 100 99 98 97)
</pre>

<!--
==== string-replicate
============================================================================-->
<dt class=proc-def>
<a name="string-replicate"></a>
<code class=proc-def>string-replicate</code><var> s from to [start end] → string</var>
<dd class=proc-def>
    This is an "extended substring" procedure that implements replicated
    copying of a substring of some string.

    <p>
    <var>S</var> is a string; <var>start</var> and <var>end</var> are optional arguments that demarcate
    a substring of <var>s</var>, defaulting to 0 and the length of <var>s</var> (<em>i.e.</em>, the whole
    string). Replicate this substring up and down index space, in both the
    positive and negative directions. For example, if <var>s</var> = "abcdefg", <var>start</var>=3, 
    and <var>end</var>=6, then we have the conceptual bidirectionally-infinite string
<div class=inset>
<table>
<tr align=right>
<td>...  <td>d  <td>e  <td>f  <td>d  <td>e  <td>f  <td>d  <td>e  <td>f  <td>d  <td>e  <td>f  <td>d  <td>e  <td>f  <td>d  <td>e  <td>f  <td>d  <td>...
</tr>
<tr align=right>
<td>... <td>-9 <td>-8 <td>-7 <td>-6 <td>-5 <td>-4 <td>-3 <td>-2 <td>-1  <td>0  <td>+1  <td>+2  <td>+3  <td>+4  <td>+5  <td>+6  <td>+7  <td>+8  <td>+9 <td>...
</tr>
</table>
</div>

    <code>string-replicate</code> returns the substring of this string beginning at index <var>from</var>,
    and ending at <var>to</var>.  Note that these arguments cannot be cursors.
    It is an error if <var>from</var> is greater than <var>to</var>.

    <p>
    You can use <code>string-replicate</code> to perform a variety of tasks:
    <ul>
    <li> To rotate a string left:  <code>(string-replicate "abcdef" 2 8)</code>  =&gt; <code>"cdefab"</code>
    <li> To rotate a string right: <code>(string-replicate "abcdef" -2 4)</code> =&gt; <code>"efabcd"</code>
    <li> To replicate a string:    <code>(string-replicate "abc" 0 7)</code> =&gt; <code>"abcabca"</code>
    </ul>

    <p>
    Note that 
      <ul>
      <li> The <var>from</var>/<var>to</var> indexes give a half-open range — the characters from
        index <var>from</var> up to, but not including, index <var>to</var>.
      <li> The <var>from</var>/<var>to</var> indexes are not in terms of the index space for string <var>s</var>.
        They are in terms of the replicated index space of the substring
        defined by <var>s</var>, <var>start</var>, and <var>end</var>.
      </ul>

    <p>
    It is an error if <var>start</var>=<var>end</var> — although this is allowed by special
    dispensation when <var>from</var>=<var>to</var>.

    <p>
    Compatibility note:  <code>string-replicate</code> is identical to the <code>xsubstring</code>
    procedure of <a href="#SRFI-13">SRFI 13</a>, except that the <var>to</var> argument is required.

<!--
==== string-count
============================================================================-->
<dt class=proc-def>
<a name="string-count"></a>
<code class=proc-def>string-count</code><var> s pred [start end] → integer</var>
<dd class=proc-def>
    Return a count of the number of characters in <var>s</var> that satisfy the
    <var>pred</var> argument.

<!--
==== string-replace
============================================================================-->
<dt class=proc-def>
<a name="string-replace"></a>
<code class=proc-def>string-replace</code><var> s1 s2 start1 end1 [start2 end2] → string</var>
<dd class=proc-def>
    Returns
<pre class=code-example>
(string-append (substring/cursors <var>s1</var> (string-cursor-start s1) <var>start1</var>)
               (substring/cursors <var>s2</var> <var>start2</var> <var>end2</var>)
               (substring/cursors <var>s1</var> <var>end1</var> (string-cursor-end <var>s1</var>)))
</pre>

    That is, the segment of characters in <var>s1</var> from <var>start1</var> to <var>end1</var>
    is replaced by the segment of characters in <var>s2</var> from <var>start2</var> to <var>end2</var>.
    If <var>start1</var>=<var>end1</var>, this simply splices the <var>s2</var> characters into <var>s1</var> at the
    specified index.

    <p>
    Examples:
<pre class=code-example>
(string-replace "The TCL programmer endured daily ridicule."
                "another miserable perl drone" 4 7 8 22 ) =&gt;
    "The miserable perl programmer endured daily ridicule."

(string-replace "It's easy to code it up in Scheme." "lots of fun" 5 9) =&gt;
    "It's lots of fun to code it up in Scheme."

(define (string-insert s i t) (string-replace s t i i))

(string-insert "It's easy to code it up in Scheme." 5 "really ") =&gt;
    "It's really easy to code it up in Scheme."
</pre>

<!--
==== string-split
============================================================================-->
<dt class=proc-def>
<a name="string-split"></a>
<code class=proc-def>string-split</code><var> s delimiter [grammar limit start end] → list</var>
<dd class=proc-def>
   Returns a list of the words contained in the substring of <em>string</em> from <em>start</em> (inclusive)
to <em>end</em> (exclusive).
<em>Delimiter</em> specifies a string that is to be used as the word separator.
This will often be a single character, but multiple characters are allowed
for cases like splitting on <code>"\r\n"</code>.
The returned list will then have one more item than the number of non-overlapping occurrences of the delimiter
in the string.  If <em>delimiter</em> is an empty string, then the returned list contains a list of strings,
each of which contains a single character. 
</p>
<p><var>Grammar</var> is a symbol with the same meaning as in the <code>string-join</code> procedure.
If it is <code>infix</code>, which is the default, processing is done as described above, except that
an empty <var>s</var> produces the empty list; if it is <code>strict-infix</code>, an empty <var>s</var>
signals an error.  The values <code>prefix</code> and <code>suffix</code> cause a leading/trailing empty
string in the result to be suppressed.</p>
<p>
If <em>limit</em> is a non-negative exact integer, at most that many splits occur, and the remainder of <em>string</em>
is returned as the final element of the list (thus, the result will have at most <em>limit</em>+1 elements).
If <em>limit</em> is not specified or is <code>#f</code>, then as many splits as possible are made.
It is an error if <em>limit</em> is any other value.
</p>
<p>Use SRFI 115's <code>regexp-split</code> to split on a regular expression
rather than a simple string.</p>

<!--
==== string-filter string-remove
============================================================================-->
<dt class=proc-def1>
<a name="string-filter"></a>
<a name="string-remove"></a>
<code class=proc-def>string-filter</code><var> pred s [start end] → string</var>
<dt class=proc-defn><code class=proc-def>string-remove</code><var> pred s [start end] → string</var>
<dd class=proc-def>
    Filter the string <var>s</var>, retaining only those characters that
    satisfy / do not satisfy <var>pred</var>.

    <p>
    If the string is unaltered by the filtering operation, these
    functions may return either <var>s</var> or a copy of <var>s</var>.

    <p>
    Compatibility note: <code>string-remove</code> is identical to the <code>string-delete</code> procedure
    of <a href="#SRFI-13">SRFI 13</a>, but the name <code>string-delete</code> is inconsistent with the
    conventions of SRFI 1 and other SRFIs. 


</dl>

<!--========================================================================-->
<h1><a name="SampleImp">Sample implementation</a></h1>

<p>
This SRFI comes with a sample implementation, which can be found in the repository
of this SRFI.  It is a cut-down version of the sample implementation of SRFI 13, with
the addition of the cursor operations procedures, the <code>*/cursors</code> procedures,
<code>string-contains-right</code>,
and <code>string-split</code>.  Here are Olin's original implementation notes:
</p><blockquote>
<p>I have placed this source on the Net with an unencumbered, "open" copyright.
The prefix/suffix and comparison routines in this code had (extremely distant)
origins in MIT Scheme's string lib, and were substantially reworked by myself.
Being derived from that code, they are covered by the MIT Scheme copyright,
which is a generic BSD-style open-source copyright. See the source file for
details.

<p>
The KMP string-search code was influenced by implementations written by
Stephen Bevan, Brian Denheyer and Will Fitzgerald. However, this version was
written from scratch by myself.

<p>
The remainder of the code was written by myself for scsh or for this SRFI; I
have placed this code under the scsh copyright, which is also a generic
BSD-style open-source copyright.

<p>
The code is written for portability and should be straightforward to port to
any Scheme. The source comments contains detailed notes describing the
non-<abbr title="Revised<sup>5</sup> Report on Scheme"><a href="#R5RS">R5RS</a></abbr>
dependencies.

<p>
The library is written for clarity and well-commented.  Fast paths are provided for common
cases. This is not to say that the implementation can't be tuned up for a
specific Scheme implementation. There are notes in the comments addressing
ways implementors can tune the reference implementation for performance.

<p>
In short, I've written the reference implementation to make it as painless
as possible for an implementor — or a regular programmer — to adopt this
library and get good results with it.
</blockquote>
<p>Another implementation, derived from Chibi Scheme's SRFI 130, is present
in the foof subdirectory.  This implementation is smaller but may be slower.
It can be more easily adapted to Schemes that differentiate between indexes
and cursors.</p>
<!--========================================================================-->
<h1><a name="Acknowledgements">Acknowledgements</a></h1>

<p>
Thanks to the members of the SRFI 130 mailing list who made this SRFI
what it now is, including Per Bothner, Arthur Gleckler, Shiro Kawai, Jim Rees, and
especially Alex Shinn, whose idea it was to make cursors and indexes
disjoint, and who provided the foof implementation.  The following
acknowledgements by Olin Shivers are taken from SRFI 13:
<blockquote>
The design of this library benefited greatly from the feedback provided during
the SRFI discussion phase. Among those contributing thoughtful commentary and
suggestions, both on the mailing list and by private discussion, were Paolo
Amoroso, Lars Arvestad, Alan Bawden, Jim Bender, Dan Bornstein, Per Bothner,
Will Clinger, Brian Denheyer, Mikael Djurfeldt, Kent Dybvig, Sergei Egorov,
Marc Feeley, Matthias Felleisen, Will Fitzgerald, Matthew Flatt, Arthur A.
Gleckler, Ben Goetter, Sven Hartrumpf, Erik Hilsdale, Richard Kelsey, Oleg
Kiselyov, Bengt Kleberg, Donovan Kolbly, Bruce Korb, Shriram Krishnamurthi,
Bruce Lewis, Tom Lord, Brad Lucier, Dave Mason, David Rush, Klaus Schilling,
Jonathan Sobel, Mike Sperber, Mikael Staldal, Vladimir Tsyshevsky, Donald
Welsh, and Mike Wilson. I am grateful to them for their assistance.

<p>
I am also grateful to the authors, implementors and documentors of all the systems
mentioned in the introduction. Aubrey Jaffer and Kent Pitman should be noted
for their work in producing Web-accessible versions of the
<abbr title="Revised<sup>5</sup> Report on Scheme"><a href="#R5RS">R5RS</a></abbr> and Common
Lisp spec, which was a tremendous aid.

<p>
This is not to imply that these individuals necessarily endorse the final
results, of course. 

<p>
During this document's long development period, great patience was exhibited
by Mike Sperber, who is the editor for the SRFI, and by Hillary Sullivan,
who is not.
</blockquote>

<!--========================================================================-->
<h1><a name="Links">References &amp; links</a></h1>

<dl>

<dt class=biblio><strong><a name="CommonLisp">[CommonLisp]</a></strong></dt>
<dd><em>Common Lisp: the Language.</em><br>
Guy L. Steele Jr. (editor).<br>
Digital Press, Maynard, Mass., second edition 1990.<br>
Available at <a href="http://www.elwood.com/alu/table/references.htm#cltl2">
http://www.elwood.com/alu/table/references.htm#cltl2</a>.
<p>

The Common Lisp "HyperSpec," produced by Kent Pitman, is essentially
the ANSI spec for Common Lisp:
<a href="http://www.lispworks.com/documentation/HyperSpec/Front/index.htm">
http://www.lispworks.com/documentation/HyperSpec/Front/index.htm</a>.

<dt class=biblio><strong><a name="MIT-Scheme">[MIT-Scheme]</a></strong>
<dd>
    <a href="http://www.swiss.ai.mit.edu/projects/scheme/">http://www.swiss.ai.mit.edu/projects/scheme/</a>

<dt class=biblio><strong><a name="R5RS">[R5RS]</a></strong></dt>
<dd>Revised<sup>5</sup> report on the algorithmic language Scheme.<br>
    R. Kelsey, W. Clinger, J. Rees (editors). <br>
    Higher-Order and Symbolic Computation, Vol. 11, No. 1, September, 1998. <br>
    and ACM SIGPLAN Notices, Vol. 33, No. 9, October, 1998. <br>
    Available at <a href="http://www.schemers.org/Documents/Standards/">
    http://www.schemers.org/Documents/Standards/</a>.

<dt class=biblio><strong><a name="R7RS">[R7RS]</a></strong></dt>
<dd>Revised<sup>7</sup> report on the algorithmic language Scheme.<br>
    A. Shinn, J. Cowan, A. Gleckler (editors). <br>
    Available at <a href="http://r7rs.org">
    http://r7rs.org</a>.

<dt class=biblio><strong>[SRFI]</strong></dt>
<dd>
    The SRFI web site. <br>
    <a href="https://srfi.schemers.org/">http://srfi.schemers.org/</a>

<dt class=biblio><strong><a name="SRFI-13">[SRFI-13]</a></strong></dt>
<dd>
    SRFI-13: String libraries. <br>
    <a href="https://srfi.schemers.org/srfi-13/">http://srfi.schemers.org/srfi-13/</a>


<dt class=biblio><strong><a name=SRFI-14>[SRFI-14]</a></strong>
<dd>
    SRFI-14: Character-set library. <br>
    <a href="https://srfi.schemers.org/srfi-14/">http://srfi.schemers.org/srfi-14/</a> <br>
    The SRFI 14 char-set library defines a character-set data type,
    which is used by some procedures in this library.

</dl>

<!--========================================================================-->
<h1><a name="Copyright">Copyright</a></h1>

    
<p>
Copyright (C) Olin Shivers (1998, 1999, 2000) and John Cowan (2016).

<p>
Permission is hereby granted, free of charge, to any person obtaining
a copy of this software and associated documentation files (the
"Software"), to deal in the Software without restriction, including
without limitation the rights to use, copy, modify, merge, publish,
distribute, sublicense, and/or sell copies of the Software, and to
permit persons to whom the Software is furnished to do so, subject to
the following conditions:
</p>
<p>
The above copyright notice and this permission notice shall be
included in all copies or substantial portions of the Software.
</p>
<p>
THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE
LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION
OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION
WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
</p>
  <hr>
  <address>Editor: <a href="mailto:srfi-editors+at+srfi+dot+schemers+dot+org">Arthur A. Gleckler</a></address>
</body>
</html>

<!--FIXME string-reverse string-map string-for-each -->
